\chapter{Simple Zero-Knowledge Polynomial Commitment}

In this chapter, we describe a simple method to add the zero-knowledge property to a given polynomial commitment scheme. This method uses random numbers to hide the actual coefficients and it works similarly to one-time pad encryption.

\section{Proximity Test}

Prover $\mathcal{P}$'s input: 
$$
    M_0 \in \mathbb{F}^{\overbrace{m \times m \times \cdots \times m}^{t \text{ times}}}
$$
$$
    M_0^{\prime} = \text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{t-1}(M_0 \oplus PAD_0) \in \mathbb{F}^{\overbrace{N \times N \times \cdots \times N}^{t-1 \text{ times}} \times m}
$$

Verifier $\mathcal{V}$'s input: nothing.

At a high level, the protocol consists of $t-1$ rounds, with each round reducing the dimension by 1. The protocol proceeds as follows. 

\begin{itemize}
    \item Let $M_0 = u$ and $PAD_0$ be a tensor with dimensions identical to $M_0$ filled with random elements from $\mathbb{F}$.
Let 
$$
    M_0^{\prime} = \text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{t-1} (M_0 \oplus PAD_0) \in \mathbb{F}^{\overbrace{N \times N \times \cdots \times N}^{t-1 \text{ times}} \times m}
$$
$$
    PAD_0^{\prime} = \text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{t-1} (PAD_0) \in \mathbb{F}^{\overbrace{N \times N \times \cdots \times N}^{t-1 \text{ times}} \times m}
$$
where $\oplus$ denotes elements-wise tensor addition.
$\mathcal{P}$ sends $M_0^{\prime}$ and $PAD_0\prime$ to $\mathcal{V}$.

    \item Round $i$ for $i \in [t-1]$
    
    \begin{itemize}
        \item $\mathcal{V}$ sample a random variable $r_i \in \mathbb{F}^m$ and send $r_i$ to $\mathcal{P}$.
        \item $\mathcal{P}$ computes a linear combination for $M_i, PAD_i \in \mathbb{F}^{\overbrace{m \times m \times \cdots \times m}^{t-i \text{ times}}}$ of their last dimension.
        Namely, for $1 \le j_1,j_2, \cdots, j_{t-i} \le m$:
$$
    M_i[j_1,j_2, \cdots, j_{t-i}] = \sum_{k=1}^{m} r_{i}[k] \cdot M_{i-1}[j_1,j_2, \cdots, j_{t-i}, k]
$$
$$
    PAD_i[j_1,j_2, \cdots, j_{t-i}] = \sum_{k=1}^{m} r_{i}[k] \cdot PAD_{i-1}[j_1,j_2, \cdots, j_{t-i}, k]
$$
        \item $\mathcal{P}$ computes
$$
M_i^\prime = \text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{t - i - 1}(M_i \oplus PAD_i)\in \mathbb{F}^{\overbrace{N \times N \times \cdots \times N}^{t-i-1 \text{ times}} \times m}
$$
$$
PAD_i^\prime = \text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{t - i - 1}(PAD_i)\in \mathbb{F}^{\overbrace{N \times N \times \cdots \times N}^{t-i-1 \text{ times}} \times m}
$$
        \item $\mathcal{P}$ sends $M_i^{\prime}$ and $PAD_i^\prime$ to $\mathcal{V}$.
    \end{itemize}
    
    \item $\mathcal{V}$ will perform a probabilistic check to make sure 
$M_0^\prime$, $M_1^\prime$, $M_2^\prime, \cdots, M_{t}^\prime, PAD_0^\prime$, $PAD_1^\prime$, $PAD_2^\prime, \cdots, PAD_{t}^\prime$ are consistent with each other.

Formally speaking, in step 1, the verifier will sample $l_1$ random tuple $(j_1, j_2, \cdots, j_t)$ from space $\underbrace{[N] \times [N] \times \cdots \times [N]}_{t \text{ times}}$. Denote this set of tuples as $L_1$.
For each sampled tuple $(j_1, j_2, \cdots, j_t)$, the verifier will check the following equation holds for every $i \in [t-1]$.
$$
    \text{Enc}(M_i^\prime[j_1, j_2, \cdots, j_{t-i-1}, *])[j_{t-i}] \stackrel{?}{=} \sum_{k=1}^m r_i[k] \cdot M_{i-1}^{\prime}[j_1,j_2, \cdots, j_{t-i},k]
$$
Then, in step 2, the verifier will sample another $l_2$ random tuple $(j_1^\prime, j_2^\prime, \cdots, j_t^\prime)$ from space $\underbrace{[N] \times [N] \times \cdots \times [N]}_{t \text{ times}}$ with the restriction that $j_k^\prime \neq j_k$ for $\forall (j_1, j_2, \cdots, j_t) \in L_1$. Denote this set of tuples as $L_2$.
For each sampled tuple $(j_1^\prime, j_2^\prime, \cdots, j_t^\prime)$, the verifier will check the following equation holds for every $1 \le i \le t-2$.
$$
    \text{Enc}(PAD_i^\prime[j_1, j_2, \cdots, j_{t-i-1}, *])[j_{t-i}] \stackrel{?}{=} \sum_{k=1}^m r_i[k] \cdot PAD_{i-1}^{\prime}[j_1,j_2, \cdots, j_{t-i},k]
$$
    
\end{itemize}


% \textbf{Evaluation Phase.}

% Let $q_1, q_2, \cdots, q_t \in \mathbb{F}^{m}$ be vectors such that $g(x) =\langle q_1 \otimes q_2 \otimes \cdots \otimes q_t, u \rangle $. The evaluation phase is identical to the testing phase, except for the following difference.

% \begin{itemize}
%     \item One additional round is required. There are $t$ rounds in total. In round $t$, $M_t^\prime$ and $ PAD_t^\prime$ are degenerated to a single value.

%     \item In round $i$, the random value $r_i$ is replaced by $q_i$.
    
%     \item For every sampled tuple $(j_1, j_2, \cdots, j_t)$ in step 1, the following restriction is required, $j_k \neq j_k^\prime$ for $\forall (j_1^\prime, j_2^\prime, \cdots, j_t^\prime) \in L_2$.

%     \item For every sampled tuple $(j_1^\prime, j_2^\prime, \cdots, j_t^\prime)$ in step 2, the following restriction is required, $j_k^\prime \neq j_k$ for $\forall (j_1, j_2, \cdots, j_t) \in L_1$.
% \end{itemize}

% If all consistent checks passed, then the verifier outputs $M_{t}^{\prime} - PAD_t^\prime$ as $g(x)$.

\section{Formal Description}

\subsection{Notation}

\subsubsection{Fold Operation}

Define $\textbf{Fold}_i(X, r)$ to be the operation taking a linear combination of $X$ across the $i$-th dimension according to coefficient $r$. 

Namely, for indexes $j_1, \cdots, j_{i-1}, j_{i+1}, \cdots , j_{k} \ge 1$:
$$
\textbf{Fold}_i(X, r)[j_1, \cdots, j_{i-1}, j_{i+1}, \cdots , j_{k}] = \sum_{k=1}^{m} r_{i}[k] \cdot X[j_1, \cdots, j_{i-1}, k, j_{i+1}, \cdots , j_{k}]
$$

\subsubsection{Encode Operation}

Define $\textbf{Enc}_{1,\cdots,i}$ be short-hand for $\text{Enc}_1 \circ \text{Enc}_2 \circ \cdots \circ \text{Enc}_{i}$.

\subsection{Proximity Test}

In this section, we describe the testing phase in the above protocol formally in terms of an IOPP (interactive oracle proof of proximity) with point queries for the relation $R_\otimes(\mathbb{F}, C, m, N, t)$ between a prover $\textbf{P}$ and a verifier $\textbf{V}$.

The prover $\textbf{P}$ takes as input an instance $\mathbb{X} = (\mathbb{F}, C, m, N, t)$ and witness $\mathbb{W} = (M_0^{\prime}, M_1^{\prime}, \cdots, M_{t-1}^{\prime}, PAD_0^{\prime}, PAD_1^{\prime}, \cdots, PAD_{t-1}^{\prime})$. The verifier $\textbf{V}$ takes as input the instance $\mathbb{X}$.

\begin{enumerate}
    \item \textit{Interactive phase}. 
    
    In the beginning, $\textbf{P}$ sends the proof message $M_0^{\prime}$ and $PAD_0^{\prime}$ computed as:
$$
    M_0 = u \in \mathbb{F}^{m^t}
$$
$$
    M_0^{\prime} = \textbf{Enc}_{1,\cdots,t-1}(M_0 \oplus PAD_0) \in \mathbb{F}^{N^{t-1} \cdot m}
$$
$$
    PAD_0^{\prime} = \textbf{Enc}_{1,\cdots,t-1}(PAD_0) \in \mathbb{F}^{N^{t-1} \cdot m}
$$
    Note that $PAD_0$ is a matrix with a dimension identical to $M_0$ filled with random elements from $\mathbb{F}$. And $\oplus$ denotes elements-wise matrix addition.
    
    For each round $i \in [t-1]$:
    \begin{itemize}
        \item $\textbf{V}$ sends random challenge message $r_i \in \mathbb{F}^m$.
        \item $\textbf{P}$ sends the proof message $M_i^{\prime}$ computed as:
$$
    PAD_i = \textbf{Fold}_{t-i+1}(PAD_{i-1}, r_i) \in \mathbb{F}^{m^{t-i}}
$$
$$
    M_i = \textbf{Fold}_{t-i+1}(M_{i-1}, r_i) \in \mathbb{F}^{m^{t-i}}
$$
$$
    M_i^\prime =  \textbf{Enc}_{1, \cdots, t- i - 1}(M_i \oplus PAD_I) \in \mathbb{F}^{N^{t-i-1} \cdot m}
$$
$$
    PAD_i^\prime =  \textbf{Enc}_{1, \cdots, t- i - 1}(PAD_i) \in \mathbb{F}^{N^{t-i-1} \cdot m}
$$

    \end{itemize}
    \item \textit{Query phase}. 
    
    In step 1, the verifier $\textbf{V}$ samples $l_1$ tuples of the form $(j_1, \cdots, j_t)$ in space $[N]^t$. Denote this set of tuples as $L_1$.
    The verifier $\textbf{V}$ proceeds as follows for each sampled tuple.
    
    For each $0 \le i \le t-1$, 
    the verifier $\textbf{V}$ will query $M_{i}^{\prime}$ at $(j_1, \cdots, j_{t-i-1}, j_k)$ for each $j_k \in [m]$. 
    
    Then the verifier $\textbf{V}$ will check the following equation for $i \in [t-1]$:
\begin{equation}
\label{eq:szkpctc_eq}
    \text{Enc}_{t-i}(M_i^\prime)[i_1, \cdots, i_{t-i}] \stackrel{?}{=} \textbf{Fold}_{t-i+1}(M_{i-1}^\prime, r_i) [i_1, \cdots, i_{t-i}]
\end{equation}

    In step 2, the verifier $\textbf{V}$ samples $l_2$ tuples of the form $(j_1^\prime, \cdots, j_t^\prime)$ in space $[N]^t$ with the restriction that $j_k^\prime \neq j_k$ for $\forall (j_1, j_2, \cdots, j_t) \in L_1$. Denote this set of tuples as $L_2$.
    The verifier $\textbf{V}$ proceeds as follows for each sampled tuple.
    
    For each $0 \le i \le t-1$, 
    the verifier $\textbf{V}$ will query $PAD_{i}^{\prime}$ at $(j_1^\prime, \cdots, j_{t-i-1}^\prime, j_k^\prime)$ for each $j_k^\prime \in [m]$. 
    
    Then the verifier $\textbf{V}$ will check the following equation for $i \in [t-2]$:
\begin{equation}
\label{eq:szkpctc_eq2}
    \text{Enc}_{t-i}(PAD_i^\prime)[i_1, \cdots, i_{t-i}] \stackrel{?}{=} \textbf{Fold}_{t-i+1}(PAD_{i-1}^\prime, r_i) [i_1, \cdots, i_{t-i}]
\end{equation}




\end{enumerate}

\subsection{Proximity Test Completeness}

\begin{lemma}
\label{lemma:szkpctcc}

IOPP = ($\textbf{P}$, $\textbf{V}$) has \textbf{perfect completeness}.

\end{lemma}
\begin{proof}
We begin by noting that the queries made by $\textbf{V}$ suffice to perform the checks in the query phase (see equation \ref{eq:szkpctc_eq} and \ref{eq:szkpctc_eq2}).

Next, observe that the verifier $\textbf{V}$ checks the following equation:
$$
    \text{Enc}_{t-i}(M_i^\prime) \stackrel{?}{=} 
    \textbf{Fold}_{t-i+1}(M_{i-1}^\prime, r_i) 
$$
Note that the left side of this equation is equivalent to:
\begin{align}
\text{Enc}_{t-i}(M_i^\prime) \nonumber
&= \text{Enc}_{t-i}(\textbf{Enc}_{1, \cdots, t- i - 1}(M_i \oplus PAD_i)) \nonumber \\
&= \textbf{Enc}_{1, \cdots, t-i}(M_i \oplus PAD_i) \nonumber \\
&= \textbf{Enc}_{1, \cdots, t-i}(\textbf{Fold}_{t-i+1}(M_{i-1} \oplus PAD_{i-1}, r_i)) \label{lb:exp1} \\
\end{align}
And the right side of this equation is equivalent to:
\begin{align}
\textbf{Fold}_{t-i+1}(M_{i-1}^\prime, r_i) 
&= \textbf{Fold}_{t-i+1}(\textbf{Enc}_{1, \cdots, t- i}(M_{i-1} \oplus PAD_{i-1}), r_i) \label{lb:exp2} \\
\end{align}
Since both \textbf{Fold} and \textbf{Enc} operations are linear operation, expression \ref{lb:exp1} and  expression \ref{lb:exp2} are equivalent to each other. And similar argument applied to the equation \ref{eq:szkpctc_eq2}.
The equations checked by the verifier $\textbf{V}$ hold.

\end{proof}




\subsection{Proximity Test Soundness}

\begin{lemma}
\label{lemma:szkpctc-soundness}


IOPP = ($\textbf{P}$, $\textbf{V}$) has soundness error at most:
$$
    \epsilon_{\text{ZK}}(\Delta_\otimes, t, l_1, l_2) = \epsilon(\Delta_\otimes, t, l_1) + \frac{\epsilon(\Delta_\otimes, t, l_2)}{\epsilon(\Delta_\otimes, 2, l_2)}
$$

\end{lemma}
\begin{proof}


This protocol performs two proximity tests in parallel. One on $M_i^\prime$ tensor and the other on $PAD_i$ tensor. The soundness error would be the sum of the soundness error introduced by the first proximity test and the second proximity test.


Formally speaking, suppose 
$$
    ((\mathbb{F}, C, m, N, t), (M_0^{\prime}, M_1^{\prime}, \cdots, M_{t-1}^{\prime}, PAD_0^{\prime}, PAD_1^{\prime}, \cdots, PAD_{t-1}^{\prime}))
$$ 
is not in relation $R_\otimes$. Then either $((\mathbb{F}, C, m, N, t), (M_0^{\prime}, M_1^{\prime}, \cdots, M_{t-1}^{\prime}))$ is not in relation $R_\otimes$, 
or $((\mathbb{F}, C, m, N, t), (PAD_0^{\prime}, PAD_1^{\prime}, \cdots, PAD_{t-1}^{\prime}))$ is not in relation $R_\otimes$.

If $((\mathbb{F}, C, m, N, t), (M_0^{\prime}, M_1^{\prime}, \cdots, M_{t-1}^{\prime}))$ is not in relation $R_\otimes$, then, the soundness error introduced by this part is $\epsilon(\Delta_\otimes, t, l_1)$. 

If $((\mathbb{F}, C, m, N, t), (PAD_0^{\prime}, PAD_1^{\prime}, \cdots, PAD_{t-1}^{\prime}))$ is not in relation $R_\otimes$, then, the soundness error introduced by this part is $\frac{\epsilon(\Delta_\otimes, t, l_2)}{\epsilon(\Delta_\otimes, 2, l_2)}$.

In a complete proximity test, we use $E_{last}$ to denote the event that the last round of the test is passed. And we use $E_{other}$ to denote the event that all other tests are passed.
The soundness error is the probability the verifier is convinced by a malicious input.
The soundness error of a complete proximity test is $P_t = \epsilon(\Delta_\otimes, t, l_2)$. And it is also the probability where both event $E_{last}$ and event $E_{other}$ occur. Therefore, $P_t = P_{E_{last}} \cdot P_{E_{last}}$. Note that $P_{E_{last}}$ is actually the soundness error when $t=2$, namely, $P_{E_{last}} = \epsilon(\Delta_\otimes, 2, l_2)$. And $P_{E_{other}}$ is the soundness error introduced by the second proximity test here, where the input is malicious and all tests except the last one are passed. Therefore, $P_{E_{other}} = \frac{P_{t}}{P_{E_{last}}} = \frac{\epsilon(\Delta_\otimes, t, l_2)}{\epsilon(\Delta_\otimes, 2, l_2)}$.

\end{proof}


\subsection{Proximity Test Zero-Knowledge}

\begin{lemma}
\label{lemma:szkpc-zk}

IOPP = ($\textbf{P}$, $\textbf{V}$) is \textbf{semi-honest zero-knowledge}

\end{lemma}
\begin{proof}

For every $(\mathbb{X}, \mathbb{W}) \in R_\otimes$ and choice of verifier randomness $\rho$, we can construct the polynomial-time simulator algorithm $\textbf{S}$ as follows:


\begin{itemize}
    \item Generate matrix $M_0$ and $PAD_0$ randomly from field $\mathbb{F}$. Then compute $M_0^\prime$ and $PAD_0^\prime$ as follows:
    $$
        M_0^{\prime} = \textbf{Enc}_{1,\cdots,t-1}(M_0) \in \mathbb{F}^{N^{t-1} \cdot m}
    $$
    $$
        PAD_0^{\prime} = \textbf{Enc}_{1,\cdots,t-1}(PAD_0) \in \mathbb{F}^{N^{t-1} \cdot m}
    $$
    \item Then compute $M_i^{\prime}$ and $PAD_i^\prime$ for $i \in [t-1]$:
    $$
        PAD_i = \textbf{Fold}_{t-i+1}(PAD_{i-1}, r_i) \in \mathbb{F}^{m^{t-i}}
    $$
    $$
        M_i = \textbf{Fold}_{t-i+1}(M_{i-1}, r_i) \in \mathbb{F}^{m^{t-i}}
    $$
    $$
        M_i^\prime =  \textbf{Enc}_{1, \cdots, t- i - 1}(M_i) \in \mathbb{F}^{N^{t-i-1} \cdot m}
    $$
    $$
        PAD_i^\prime =  \textbf{Enc}_{1, \cdots, t- i - 1}(PAD_i) \in \mathbb{F}^{N^{t-i-1} \cdot m}
    $$
\end{itemize}

If the verifier query $M_i^{\prime}$ or $PAD_i^\prime$ at index $I = (j_1, j_2, \cdots, j_t)$:

\begin{itemize}
    \item If $j_k \le m$ for $\forall k \in [t]$ (this is the message part),
    
    In the simulation world, both $M_0^\prime[I]$ and $PAD_0^\prime[I]$ are uniformly random variables. And both $M_i^\prime[I]$ and $PAD_i^\prime[I]$ for $i > 0$ are linear combination of a set of uniformly random variables, which are also uniformly random variables.
    
    In the real world, $PAD_0^\prime[I]$ is a uniformly random variable by definition. $M_0^\prime[I]$ is also a uniformly random variable because $M_0^\prime[I] = u[I] + PAD_0^\prime[I]$. Similarly, both $M_i^\prime[I]$ and $PAD_i^\prime[I]$ for $i > 0$ are linear combination of a set of uniformly random variables, which are also uniformly random variables.
    
    Therefore, the verifier will see a uniformly distributed random element from $\mathbb{F}$ both in the simulation world and in the real world.
    
    \item Otherwise,
    
    In the simulation world and in the real world, $M_i^\prime[I]$ can be determined by a set of random elements in $M_i$. Denote this computation equation as $\textsc{Func}$, namely, $M_i^\prime[I] = \textsc{Func}(M_i[I_1], \cdots, M_i[I_x])$. And $M_i^\prime[I]$ will represent a distribution that is uniquely determined by function \textsc{Func} and the distribution of variables $M_i[I_1], \cdots, M_i[I_x]$. Similarly, $PAD_i^\prime[I]$ will represent a distribution that is uniquely determined by function \textsc{Func} and the distribution of variables $PAD_i[I_1], \cdots, PAD_i[I_x]$.
    
    Note that both in simulation world and in the real world, $M_i[I_1], \cdots, M_i[I_x]$ and $PAD_i[I_1], \cdots, PAD_i[I_x]$ will represent uniformly random variables. And since the function \textsc{Func} is identical in both cases, distribution of $M_i^\prime[I]$ and $PAD_i^\prime[I]$ will be identical in two worlds.
    
    
\end{itemize}



The random variables in $\textbf{S}^{\textbf{V}(\mathbb{X};\rho)}(\mathbb{X})$ and in $\text{View}(\textbf{P}(\mathbb{X}, \mathbb{W}), \textbf{V}(\mathbb{X};\rho))$ are indistinguishable to each other. They are identically distributed.

Note that although $PAD_i$ and $M_i$ are correlated (the subtraction of them is the underlying polynomial coefficients), the verifier $\mathcal{V}$ will not be able to observe this correlation because the verifier is not allowed to query both $PAD_i$ and $M_i$ at the same index. The verifier is only allowed to query one of them.

\end{proof}