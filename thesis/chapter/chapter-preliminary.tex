\chapter{Preliminaries}

\section{Combinatorics}

\begin{definition}[$d$-regular Graph]

A graph $G = (V, E)$ is $d$-regular if every vertex in $V$ has degree $d$.

\end{definition}

\begin{definition}[Set]

$[n]$ is the shorthand for the set $\{i: 1 \le i \le n\}$

\end{definition}

\section{Interactive Oracle Proof}

\begin{definition}[Relation]

An \textbf{relation} $R$ is a set of pairs $(\mathbb{X}, \mathbb{W})$ where $\mathbb{X}$ is the instance and $\mathbb{W}$ is the witness. The corresponding \textbf{language} $L(R)$ is the set of instances $\mathbb{X}$ for which there exists a witness $\mathbb{W}$ such that $(\mathbb{X}, \mathbb{W}) \in R$.

\end{definition}

\begin{definition}[Point Query Interactive Oracle Proof (IOP)]
An \textbf{Interactive Oracle Proof (IOP)} is defined by a pair of interactive randomized
algorithms \textbf{IOP = (P, V)}, where \textbf{P} denotes the prover and \textbf{V} the verifier. 
The number of rounds of interaction is called the \textbf{round complexity} of the system. 
During a single round the prover sends a message to which the verifier is given oracle access, and the verifier responds with a message to the prover. 
The \textbf{proof length} is the sum of lengths of all messages sent by the prover. Specifically, the prover is allowed to send a large array message $\pi$ to the verifier, and the verifier is allowed to query this message $\pi$ at position $I$. Then the prover will response with $\pi[I]$.
The \textbf{query complexity} of the protocol is the number of entries read by \textbf{V} from the various prover message and for each query only elements in a single point will be responded.
We denote by $\langle P \leftrightarrow V \rangle (\mathbb{X}, \mathbb{W})$ the output of \textbf{V} after interacting with \textbf{P} on instance $\mathbb{X}$ and witness $\mathbb{W}$; this output is either \textsc{accept} or \textsc{reject}.

An interactive oracle proof IOP = (P, V) for a relation R has completeness 1 and soundness error $\epsilon$ if the following holds.

\begin{enumerate}
    \item \textbf{Completeness.}
    For every pair $(\mathbb{X}, \mathbb{W}) \in R$, the probability that $P(\mathbb{X}, \mathbb{W})$ convinces $V(\mathbb{X})$ to accept is 1.
    
    \item \textbf{Soundness.}
    For every instance $\mathbb{X} \not\in L(R)$ and malicious prover $\tilde{P}$, the probability that $\tilde{P}$ convince $V(\mathbb{X})$ to accept is at most $\epsilon$.
\end{enumerate}
\end{definition}

\begin{definition}[Interactive Oracle Proof of Proximity (IOPP)]
An \textbf{Interactive Oracle Proof of Proximity (IOPP)} is defined by a pair of interactive randomized
algorithms \textbf{IOPP = (P, V)}, where \textbf{P} denotes the prover and \textbf{V} the verifier. 
The number of rounds of interaction is called the \textbf{round complexity} of the system. 
During a single round the prover sends a message to which the verifier is given oracle access, and the verifier responds with a message to the prover. 
The \textbf{proof length} is the sum of lengths of all messages sent by the prover. 
The \textbf{query complexity} of the protocol is the number of entries read by \textbf{V} from the various prover message.
We denote by $\langle P \leftrightarrow V \rangle (\mathbb{X}, \mathbb{W})$ the output of \textbf{V} after interacting with \textbf{P} on instance $\mathbb{X}$ and witness $\mathbb{W}$; this output is either \textsc{accept} or \textsc{reject}.
The protocol's goal is to show that a particular string is close to a valid witness.
An interactive oracle proof of proximity IOPP = (P, V) for a relation R has completeness 1 and soundness error $\epsilon$ with distance function $\Delta$ if the following holds.

\begin{enumerate}
    \item \textbf{Completeness.}
    For every pair $(\mathbb{X}, \mathbb{W}) \in R$, the probability that $P(\mathbb{X}, \mathbb{W})$ convinces $V^{\mathbb{W}}(\mathbb{X})$ to accept is 1.
    
    \item \textbf{Soundness.}
    For every instance $\mathbb{X} \not\in L(R)$ and malicious prover $\tilde{P}$, the probability that $\tilde{P}$ convince $V^{\mathbb{W}}(\mathbb{X})$ to accept is at most $\epsilon(\Delta(\mathbb{W}, R|_{\mathbb{X}}))$. Here the soundness error $\epsilon$ is a function of the $\Delta$-distance of $\mathbb{W}$ to the set of valid witnesses $R|_{\mathbb{X}} := \{ \mathbb{W}^\prime | (\mathbb{X}, \mathbb{W}^\prime) \in R \}$.
\end{enumerate}
\end{definition}

\section{Polynomial}

\begin{definition}[Monomials of Polynomial]
A polynomial g over $\mathbb{F}$ is an expression consisting of a sum of \textbf{monomials} where each monomial is the product of a constant (from $\mathbb{F}$) and powers of one or more variables (which take values from $\mathbb{F}$); all arithmetic is performed over $\mathbb{F}$.
\end{definition}

\begin{definition}[Degree of Polynomial]
The degree of a monomial is the sum of the exponents of variables in the monomial; the (total) degree of a polynomial g is the maximum degree of any monomial in g. Furthermore, the degree of a polynomial g in a particular variable $x_i$ is the maximum exponent that $x_i$ takes in any of the monomials in g.
\end{definition}

\begin{definition}[Multivariate / Univariate Polynomial]
A \textbf{multivariate} polynomial is a polynomial with more than one variable; otherwise it is called a \textbf{univariate} polynomial.
\end{definition}

\begin{definition}[Multilinear Polynomial]
A \textbf{multivariate} polynomial is called a \textbf{multilinear} polynomial if the degree of the polynomial in each variable is at most one.
\end{definition}

\begin{definition}[Polynomial Commitment]
A \textbf{Polynomial Commitment} consists of three algorithms:

\begin{itemize}
    \item \textsc{PC.Commit}$(\phi(\cdot))$:the algorithm outputs a commitment $\mathcal{R}$ of the polynomial $\phi(\cdot)$.
    \item \textsc{PC.Prove}$(\phi, x, \mathcal{R})$: given an evaluation point $x$, the algorithm outputs a tuple $(x, \phi(x),\pi_x)$, where $\pi_x$ is the proof.
    \item \textsc{PC.Verify}$(\pi_x, x, \phi(x), \mathcal{R})$:given $\pi_x, x, \phi(x), \mathcal{R}$, the algorithm checks if $\phi(x)$ is the correct evaluation. The algorithm outputs \textsc{accept} or \textsc{reject}.
\end{itemize}

\end{definition}

\textbf{Completeness.} Let $\mathcal{R} \leftarrow \textsc{PC.Commit}(\phi(\cdot))$ be the commitment of a polynomial. Any output $(x, \phi(x),\pi_x)$ generated by an honest prover using algorithm \textsc{PC.Prove}$(\phi, x, \mathcal{R})$, will be successfully verified by algorithm \textsc{PC.Verify}$(\pi_x, x, \phi(x), \mathcal{R})$.
$$
Pr
\begin{pmatrix}
 \mathcal{R} \leftarrow \textsc{PC.Commit}(\phi(\cdot)): \\
 (x, \phi(x),\pi_x) = \textsc{PC.Prove}(\phi, x, \mathcal{R}) \wedge \\
 \textsc{PC.Verify}(\pi_x, x, \phi(x), \mathcal{R}) = \textsc{accept }
\end{pmatrix}
= 1
$$


\textbf{Soundness.} For all adversaries $\mathcal{A}$, the soundness error $\epsilon$ is defined to be the following probability:
$$
\epsilon = Pr
\begin{pmatrix}
 (\mathcal{R}, (\phi(\cdot), \pi_x), (\phi^\prime(\cdot)), \pi_x^\prime) \leftarrow \mathcal{A}(x): \\
 \textsc{PC.Verify}(\pi_x, x, \phi(x), \mathcal{R}) = \textsc{accept } \wedge \\
 \textsc{PC.Verify}(\pi_x^\prime, x, \phi^\prime(x), \mathcal{R}) = \textsc{accept } \wedge \\
 \phi(x) \neq \phi^\prime(x)
\end{pmatrix}
$$

\textbf{Zero-knowledge.} At the end of the protocol, the verifier will know the evaluation result of the polynomial at some evaluation points, but nothing more than that.

\section{Linear Code}

\begin{definition}[Linear Code]
If $\mathbb{F}$ is a field and $C \subset \mathbb{F}^n$ is a subspace of $\mathbb{F}^n$ then C is said to be a linear code.
\end{definition}

The weight of a codeword is the number of its elements that are nonzero and the distance between two codewords is the \textbf{Hamming distance} between them, that is, the number of elements in which they differ. The distance $d$ of the linear code is the minimum weight of its nonzero codewords, or equivalently, the \textbf{minimum distance} between distinct codewords. A linear code of length $n$, dimension $k$, and distance $d$ is called an $[n,k,d]$ code.

As $C$ is a subspace, there exists a basis $c_1, c_2, \cdots, c_k$ where $k$ is the dimension of the subspace. Any codeword can be expressed as the linear combination of these basis vectors. We can write these vectors in matrix form as the rows of a $k \times n$ matrix. Such a matrix is called a \textbf{generator matrix}.

Additionally, any linear combination of valid codeword is also a valid codeword, which is the \textbf{linearity property}. Formally speaking, given $x_1, x_2, \cdots, x_n$ are valid codeword, and given $r_1, r_2, \cdots, r_n$ are some constants, $x^\prime = r_1 x_1 + r_2 x_2 + \cdots + r_n x_n$ is also a valid codeword.

\begin{definition}[Tensor Product Code]
The tensor product code $C^{\otimes t}$ is the linear code in $\mathbb{F}^{n^t}$ with message length $k^t$, block length $n^t$ and distance $d^t$ where any axis-parallel line of elements is in C.
\end{definition}

\begin{definition}[Relation $R_\otimes$]
The relation $R_\otimes$ is the sef of tuples
$$
    (\mathbb{X}, \mathbb{W}) = ((\mathbb{F}, C, l, q, t), (c_0^{0}, \{c_1^{(s)}\}_s, \cdots, \{c_{t-1}^{(s)}\}_s))
$$ 
such that $c_0^{0} \in (C^{\otimes t})^l$ and for all $r \in [t-1]$ and $s \in [q]$, we have $c_r^{(s)} \in (C^{\otimes t-r})^k$.
\end{definition}

\begin{definition}[Distance $\Delta_\otimes$]
Let $\mathbb{W} = (c_0^{0}, \{c_1^{(s)}\}_s, \cdots, \{c_{t-1}^{(s)}\}_s)$ be such that $c_0^{(0)} \in \mathbb{F}^{l \cdot n^t}$ and, for all $r \in [t-1]$ and $s \in [q]$, we have $c_r^{(s)} \in \mathbb{F}^{k \cdot n^{t-r}}$. Given $\mathbb{X} = (\mathbb{F}, C, l, q, t)$, the $\Delta_\otimes$ distance of $\mathbb{W}$ to $R_\otimes|_{\mathbb{X}}$ is
$$
    \Delta_\otimes(\mathbb{W}, R_\otimes|_{\mathbb{X}}) := \max \{\Delta_0, \Delta_1, \cdots, \Delta_{t-1}\}
$$
where $\Delta_0 := \Delta(c_0^{(0)}, C^{\otimes t})$ and $\forall r \in [t-1], \Delta_r := \Delta(\{c_r^{(s)}\}_s, C^{\otimes t-r})$.
\end{definition}