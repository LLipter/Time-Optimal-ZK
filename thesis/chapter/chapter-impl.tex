\chapter{Implementation Details}

\section{Merkle Tree Commitment}

A Merkle Tree is a data structure that allows one to commit to $l = 2^{d}$ messages by a single hash value $h$, such that revealing any bit of the message require $d+1$ hash values. A Merkle hash tree is presented by a binary tree of depth $d$ where $l$ messages elements $m_1, m_2, \cdots, m_l$ are assigned to the leaves of the tree. The values assigned to internal nodes are computed by hashing the value of its two child nodes. To reveal $m_i$, we need to reveal $m_i$ together with the values on the path from $m_i$ to the root. We denote the algorithm as follows:

\begin{enumerate}
    \item $h \leftarrow \textsc{Merkle.Commit}(m_1, m_2, \cdots, m_l)$
    \item $(m_i, \phi_i) \leftarrow \textsc{Merkle.Open}(m, i)$
    \item $\{\textsc{accept}, \textsc{reject}\} \leftarrow \textsc{Merkle.Verify}(\phi_i, m_i, h)$
\end{enumerate}

In practice, we use Merkle tree commitment to compile the IOP or IOPP to an real argument system. Each element in the large array message $\pi$ sent by the prover will be considered to be a leaf node of a Merkle tree. And the corresponding Merkle tree root will be sent to the verifier instead. For each query at position $I$, the prover will responds with $\pi[I]$ and the corresponding Merkle tree path, which will be authenticated later by the verifier.

Coefficient matrices $M_0^\prime, M_1^\prime, \cdots, M_{t-1}^\prime$ sent by the prover may be replaced by a Merkle tree commitment to that matrix. And since each time the verifier will query a strip of elements in a matrix (i.e. $M_i^\prime[i_1, i_2, \cdots, i_{t-i-1}, *]$), it is possible to zip such a strip of elements into a single node in Merkle-tree's leaf level to decrease runtime complexity and communication complexity.

\section{Zero-knowledge Merkle Tree Commitment}

To implement a zero-knowledge polynomial commitment scheme, we also need a zero-knowledge Merkle tree commitment to prevent information leaking from the Merkle tree path. If we use the random oracle model, we can argue that the Merkle hash is completely random, thus, leaking no information at all. On the other hand, we can prevent information leaking by adding randomness into the leaf nodes. The leaf node is $hash(data_i || r_i)$ where $r_i$ is some random elements. 

\section{Parallelism}

Most of the computations for the polynomial commitment scheme can be done in parallel in a natural fashion. There is little data dependence among them. Therefore, it is possible to run the commitment scheme using multiple threads to increase efficiency significantly for both the prover and the verifier.